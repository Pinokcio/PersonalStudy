* 컨디션 변수
- 쓰레드가 실행을 계속 진행하기 전에 어떤 조건이 참인지 검사해야하는 경우가 많이 있다.
  > 대표적으로 부모 쓰레드가 작업을 시작하기 전에 자식 쓰레드가 작업을 끝냈는지를 검사하는 경우가 있다.
  > 이러한 과정을 join()이라고 부른다.
- 일종의 큐 자료구조
- 어떤 실행의 상태 또는 조건이 원하는 것과 다를 때, 같아지기를 기다리며 쓰레드가 대기할 수 있도록 함.
- 다른 쓰레드가 상태를 변경시켰을 때, 대기 중이던(하나 혹은 이상의) 쓰레드에 시그널을 보내서 깨워 실행을
  계속 할 수 있도록 함.
  
pthread_cond_t c = PHTREAD_COND_INITIALIZER;
pthread_cond_wait(pthread_cond_t * c, pthread_mutex_t * m);
pthread_cond_signal(pthread_cond_t * c);

- wait()은 스스로를 재우기 위해 사용
- signal()은 wait중인 쓰레드에 신호를 보내서 깨우기 위해 사용
- 특이한 점은 wait()은 mutex를 매개변수로 사용한다는 것이다.
  > wait()은 호출 시, 락이 잠겨 있었다고 가정하며, 해당 락을 해제하고 호출한 쓰레드를 재운다.
  > 다른 쓰레드에 의해 깨어날 때는, wait()에서 리턴하기 전 락을 다시 획득하기를 시도한다.
    = 만약 락 획득에 실패하면 다시 sleep 상태로 돌아간다.
- 또 주목할 점은, wait() / signal() 이 별도의 공유 변수와 함께 사용된다는 것이다.

* 생산자/소비자(유한 버퍼) 문제
- 동기화와 관련된 유명한 문제
- 다수의 생산자 쓰레드와 소비자 쓰레드가 존재
  > 생산자 쓰레드는 데이터를 생성하여 (유한) 버퍼에 넣음
  > 소비자 쓰레드는 (유한) 버퍼에서 데이터를 꺼내어 사용
  ex) 멀티 쓰레드 웹 서버, 파이프를 통한 redirection  
- 유한 버퍼는 공유 자원으로, 경쟁 조건의 발생을 방지하기 위해서 동기화가 필요하다.

! 공유 자원의 상태에 따라 쓰레드를 재울 때에는 if가 아닌 while을 사용해야 하며, fill 과 empty 상태 각각에
  대한 컨디션 변수를 사용해야 유한 버퍼 문제를 해결할 수 있다.
  
*  최종적인 생산자/소비자 해법
- 유한 버퍼의 크기를 늘린다.
  > 단일 생산자/소비자 모델 -> 쓰레드간 문맥 교환이 줄어들기 때문에 효율적이 됨
  > 멀티 생산자/소비자 모델 -> 생산 및 소비가 병행이 될 수 있기 때문에 병행성이 좋아짐
- put() / get()은 여러 데이터를 담을 수 있도록 변경
- 생산자/소비자 쓰레드의 경우, wait() 및 signal()을 버퍼가 가득 찼을 때 혹은 완전히 비었을 때로 수정.

* 컨디션 변수 사용 시 주의점
- 메모리 할당 시, 잔여 공간이 부족할 경우 공간이 생길 때까지 wait()로 기다림
- 메모리 반납 시, 사용 가능한 공간의 발생을 signal()로 알림
- signal()사용시 sleep상태인 쓰레드 중 어떤 쓰레드가 조건을 만족하는지 알 수 없기 때문에 우선 broadcast()로
  모든 쓰레드를 깨운 뒤 조건을 확인하여 해당하지 않는 쓰레드는 다시 재우는 방식으로 동작하도록 한다.
  > 이처럼 보수적으로 모든 쓰레드를 깨워서 조건을 검사하고, 다시 대기 상태로 돌아가도록 하는 것을 포함 조건
    (Covering Condition) 이라고 한다.
