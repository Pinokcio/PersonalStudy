@ 병행성 관련 프로그램 버그
- 완성도 높은 코드에서 비 교착상태 버그가 교착상태 버그보다 많이 발견됨

* 비 교착상태 버그
- 병행성 버그의 대부분을 차지
- 비교착 상태 버그의 97%를 차지하는 대표적인 두 종류의 버그
  > 원자성 위반 : 다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성이 보장되지 않음 -> 공유 객체를 락으로
  감싸서 해결한다.
  > 순서 위반 : 두 개의 메모리 참조 간의 순서가 바뀌었다. -> 컨디션 변수 이용

* 교착상태 버그
- 복잡한 락 프로토콜을 사용하는 다수의 병행 시스템에서 교착 상태가 발생
ex) 락L1을 가지고 있는 쓰레드 1이 또 다른 락L2를 기다리는 상황에서, 락L2를 가지고 있는 쓰레드2가 락L1이
해제되기를 기다리면 교착상태 발생

! 교착상태 발생 원인
- 앞선 예시의 경우 T1,T2가 L1,L2를 같은 순서로 획득하게 하면 교착 상태는 발생하지 않는다.
- 교착 상태 발생 이유
  1. 코드가 많아지면서 구성 요소 간에 복잡한 의존성이 발생
  2. 캡슐화의 성질. 개발자들은 모듈화를 통해 프로그램을 간결하고 재사용 가능하게 하지만, 모듈화는 락과 잘
  조화되지 않는다.
  
* 교착상태의 발생 조건
1. 상호 배제 : 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장한다.
2. 점유 및 대기 : 쓰레드가 자신에게 할당된 자원을 점유한 채로 다른 자원 획득을 대기한다.
3. 비 선점 : 자원을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없다.
4. 순환 대기 : 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원을 가지고 있는 쓰레드들의 순환고리가 
   있다.
- 이들 조건 중 하나라도 만족하지 않으면 교착 상태는 발생하지 않는다.

* 교착 상태의 예방 : 순환 대기
- 가장 실용적이면서 많이 사용되는 예방 기법
- 락 획득을 하는 전체 순서를 정해서 순환 대기가 발생하지 않도록 함
- 복잡한 시스템의 경우 전체 순서를 정하는 것이 복잡해질 수 있으며, 이 때는 부분 순서를 제공하는 것이 유용
- 다만, 락 획득을 하는 전체 혹은 부분 순서라는 것은 코드 별로 존재하는 관례이기 때문에, 숙달되지 않을 경우
  실수할 가능성이 높음
- 또한 다양한 루틴 간의 상호 호출 관계를 이해해야 락의 순서를 정의할 수 있다.
- 락 주소를 이용하여 락 요청 순서를 강제하는 것이 도움이 될 수 있다.
ex)
if(m1>m2){
  pthread_mutex_lock(m1);
  pthread_mutex_lock(m2);
}else{
  pthread_mutex_lock(m2);
  pthread_mutex_lock(m1);
}

* 교착 상태의 예방 : 점유 및 대기
- 점유 및 대기는 원자적으로 모든 락을 한 번의 획득하도록 하면 예방할 수 있다.
- 그러나 이 방법은 필요한 락을 정확히 파악하여 미리 획득해야 하고, 실제 필요할 때 락을 획득하는 것이 아니라
  전체 락을 일괄 획득하기 때문에 병행성이 저하될 수 있다.
  
* 교착 상태의 예방 : 비선점
- 다수의 락을 획득할 때, 하나의 락을 획득한 상태로 다른 락을 획들하려 대기 하는 것은 문제를 일으킬 수 있다.
- trylock()을 이용하여 해결 -> 다수의 락 획득 시, 일부 락만 획득한 후 대기하는 것을 피한다. 
  > 그러나 일부 쓰레드가 계속 락 획득 / 해제를 반복하는 무한반복(livelock)문제가 발생할 수 있게 된다.

* 교착 상태의 예방 : 상호 배제
- 상호 배제 자체를 업애면 교착 상태가 발생하지 않을 것이다.
- 일반적 코드는 모두 임계 영역을 포함하고 있기 때문에 어렵다.
- 대기 없는 자료구조 만드는 것을 고려
- CompareAndSwap(CAS)를 이용하면 락 없이 원자적으로 특정 값을 증가시킬 수 있다.
  > 단, ABA 문제(이전에 사용됐던 메모리가 재사용되면서 발생하는 문제)가 발생할 수 있음

* 스케줄링으로 교착 상태 회피
- 어떤 쓰레드가 어떤 락을 획득하게 될 것인지 파악하고 있는 상태에서, 이를 바탕으로 쓰레드들을 스케줄링하여
  교착 상태가 발생하지 않도록 한다.
  > 같은 락 획득을 목적으로 하는 두개의 쓰레드가 서로 같은 시간에 실행되지 않도록 한다.
  > 같은 락 획득을 목적으로 하는 두 개 이상의 쓰레드가 모두 하나의 CPU에서 순차적으로 실행되도록 한다.
  
* 발견 및 복구
- 교착 상태가 발생하는 것을 인정하고, 만약 실제 발생할 경우 이를 복구하는 것도 가능하다.
  > 교착 상태가 빈번하게 발생하지 않으며 발생 시 피해가 미미할 것이라는 전제하에 유효하다.
- 많은 데이터 베이스 시스템에서 교착 상태를 검축하고 복구 하기 위한 기술들을 사용한다.

