* 이벤트 기반의 병행성
- 쓰레드를 사용하지 않는 다른 스타일의 병행 프로그래밍 중 하나
  > GUI 기반 프로그램들에서 많이 사용됨
- 이벤트 기반 병행성은 다음 문제를 해결한다.
  > 멀티 쓰레드 프로그램에서 병행성 문제가 발생하는 것 방지
    - 락을 사용하지 않거나, 교착 상태가 발생하는 등
  > 멀티 쓰레드 프로그램에서, 개발자는 쓰레드가 어떻게 스케줄링 될지 전혀 모름
    - 즉, 운영체제가 합리적으로 최적화된 방법으로 쓰레드를 스케줄링 할 것이라고 믿어야만 함

* 이벤트 루프 
- 접근법
  . 사건(이벤트)의 발생을 기다림
  . 이벤트가 발생하면 이벤트의 종류를 파악하고,
  . 해당 이벤트를 처리함
    > I/O 요청, 추후 처리를 위한 다른 이벤트 발생 등
- 기본 형태
  while(1){
    events = getEvents();
    for( e in events )
      processEvent(e);
  }
    . 루프 내에서 이벤트가 발생하면, 이벤트 핸들러를 통해서 처리됨
    . 어떤 이벤트가 발생했는지 구분해서 처리할 수 있어야 함
      > 디스크 I/O 완료 이벤트가 발생했을 때, 어떤 디스크 요청이 완료되었는지 판단할 수 있어야 함
      
 * select()
 - 운영체제에서 제공하는 시스템 콜
 - 도착한 I/O 이벤트 중 주목할 만한 요청이 있는지 파악한다.
 
 * 왜 간단한가.
 - 단일 CPU를 사용하는 이벤트 기반 프로그램은 병행 프로그램에서 보인 문제들이 없음
 - 매 순간 하나의 이벤트만 처리하기 때문에 락 획득 및 해제의 필요가 없음
 
 * 문제점 : 블로킹 시스템 콜
 - 블로킹 vs 비블로킹
  > 블로킹 또는 동기 인터페이스는 호출자에게 리턴하기 전에 자신의 작업을 모두 처리
  > 비블로킹 또는 비동기 인터페이스는 작업을 시작하기는 하지만 즉시 반환하기 때문에 처리해야 하는 일은
    백그라운에서 완료됨
 - 이벤트 기반 프로그램에서는 블록킹 시스템 콜은 허용하면 안된다.
  > 가정 : 디스크에서 데이터를 읽어 사용자에게 전달
    . open(), read() 과정의 시스템콜이 모두 저장 장치에 I/O 요청을 보내야 하고 이 때 블로킹 된다면
      쓰레드 기반에서는 다른 쓰레드가 CPU를 사용하므로 시스템이 멈추지 않지만 이벤트 기반에서는 이벤트
      루프가 블록되버리면, 시스템은 유후상태가 된다.
 
 * 해법 : 비동기 I/O
 - 운영체제에서 I/O 요청을 비동기로 저장장치에 내려보낼 수 있는 비동기 I/O를 제공한다.
  > I/O 요청이 끝나기 전에 제어권을 호출자에게 되돌려주며, 추가적으로 I/O들이 완료 되었는지도 판단할 수
    있도록 함
 - I/O가 종료되어 버퍼에 데이터가 성공적으로 저장됐다는 것을 주기적으로 polling 하여 확인함. 따라서
   I/O 연산수가 많아지면 이는 비효율적이 될 수 있다.
 - 이 경우, 인터럽트(Interrput)를 활용할 수 있다
 
 * 시그널
 - 어떠한 이벤트가 발생했음을 알리기 위해 운영체제와 프로세스, 프로세스와 프로세스 간에 사용되는 통신 방법
 - 시그널이 프로세스에 전달되면
  > 프로세스는 시그널 핸들러를 실행하고
  > 해당 시그널 처리가 완료되면 이전 작업을 재개한다.
- 다양한 시그널들이 존재하며 때로 운영체제는 프로세스가 특정 시그널을 받지 못하도록 마스킹(masking)할 수
  있다.
- 시그널들은 각자 이름을 가지고 있으며 목적에 따라 프로세스로 전달됨
ex) HUP(연결끊김), INT(인터럽트), SEGV(세그멘테이션 위반) 등
  > signal 시스템 콜은 시그널 핸들러를 등록할 수 있도록 함
  
* 또 다른 문제점 : 상태 관리
- 이벤트 기반의 문제점은 쓰레드 기반보다 작성하기가 복잡하다는 것이다
  > 이벤트 핸들러가 비동기 I/O를 발생시켰다면, 이후 해당 I/O가 완료된 이후 이어나갈 프로그램의 상태를
    정리해놓아야 함
  > 쓰레드에서는 스택에 그 정보가 이미 들어 있기 때문에 정리 작업이 불필요
- 따라서 이벤트 기반에서는 수동 스택 관리 (Manual Stack Management)가 필요

* 해결 : continuation
- 이벤트를 종료하는데 필요한 모든 자료들을 한곳에 저장하여, 나중에 실행을 이어갈 수 있도록 하는 프로그래밍
  기법
- I/O 완료와 같은 이벤트가 발생하면 저장된 정보를 이용해 이벤트를 처리

* 이벤트 사용의 어려움
- 멀티 CPU 상에서는 이벤트 기반 접근법의 단순함이 사라짐
  > 결국 락이 필요하게 됨
- 페이징과 같은 특정 종류의 시스템과 맞지 않음
  > 페이지 폴트와 같은 내재적 원인으로 인한 중단 발생 시, 해결되기 전까지 반드시 시스템이 멈춰야하므로
    성능이 하락할 수 있음
- 이벤트 핸들러에서 사용하는 루틴들의 구현 방식이 바뀔 경우, 이를 고려해서 이벤트 핸들러가 수정되어야 함.
- 비동기 디스크 I/O가 대부분의 플랫폼에서 지원이 되지만 이렇게 되기까지는 많은 시간이 걸렸으며, API면에서도
네트워크에는 select()가 디스크에는 AIO가 사용되는 등의 비일관적인 면이 존재한다.
