* I/O를 포함한 시스템 구조
- 시스템은 메모리 버스, 범용 I/O 버스, 주변장치용 버스를 통한 계층적 구조를 취하고 있다.
  > 메모리 버스 -> 범용 I/O 버스 -> 주변장치용 버스로 갈수록 대역폭이 좁아지고 지연이 길어진다.
  > 따라서, 메모리 및 그래픽 카드와 같은 소수의 중요 장치를 우선적으로 고성능 버스에 연결한다.
  > 또한 저장장치와 같이 상대적으로 느린 장치를 저성능 버스에 연결한다.
  
* 표준 장치
- 표준 장치는 두개의 중요 요소를 가진다.
  > 하드웨어 인터페이스 : 소프트웨어가 인터페이스를 제공하는 것처럼 시스템 소프트웨어(운영체제)에게 
    특정한 상호 동작을 위한 방식과 명시적 인터페이스를 제공하여 동작을 제어하도록 함
  > 내부구조 : 시스템에 제공하는 장치에 대한 추상화를 정의하며, 간단한 하드웨어 칩셋으로 구성되거나,
    내부 CPU, 메모리 등으로 구성되어 펌웨어를 동작시키는 방식으로도 구성 가능

* 하드웨어 인터페이스 
- 상태 레지스터 : 장치의 현재 상태를 알 수 있도록 함
- 명령 레지스터 : 장치가 특정 동작을 수행하도록 요청할 수 있도록 함
- 데이터 레지스터 : 장치에 데이터를 보내거나 받을 수 있도록 함
- 운영체제는 이들 레지스터에 값을 쓰거나 읽음으로써 장치를 제어할 수 있다.

* 폴링
- 운영체제는 반복적으로 상태 레지스터를 읽어서 운영체제의 상태르 확인
  > 간단하며 잘 동작한다.
  > 하지만, 느린 입출력 장치의 동작 시간 동안 다른 프로세스에게 CPU를 양도하지 않음으로써 매우 비효율적이다.
  
* 인터럽트
- 입출력 장치를 요청한 프로세스를 블럭시키고, CPU를 다른 프로세스로 양도
- 이후, 입출력 장치가 작업을 완료하면 인터럽트를 발생시키고, CPU는 운영체제가 미리 설정해놓은 인터럽트 서비스
  루틴 (ISR) 또는 인터럽트 핸들러를 실행한다.
  
* 폴링 vs 인터럽트
- 분명 인터럽트는 폴링 대비 CPU의 유휴시간을 최소화한다.
- 그러나 항상 최적의 작업은 아님
  > 대부분의 작업이 폴링 한번에 끝날 정도로 매우 빠른 장치 가정. 이 경우 인터럽트 사용시 context-switch등의
    오버헤드로 인해 더 느려질 수 있음. 따라서, 장치의 속도에 따라 포링과 인터럽트를 적절히 사용하는 것이 필요
- 만약 장치의 속도를 모른다거나 혹은 변동이 크다면 짧은 시간동안 폴링하고 처리가 되지 않으면 인터럽트를 
  이용하는 하이브리드 방식도 좋음

* DMA (Direct Memory Access)
- DMA는 CPU와 버스를 통해 연결된 별도의 하드웨어 모듈임
- 운영체제는 DMA에 <메모리 상의 데이터 위치, 전송할 데이터의 크기, 대상 장치>를 프로그램한다.
- DMA는 프로그램 된 대로 장치와 메모리 간에 메모리 복사를 한 뒤, 완료가 되면 CPU에 인터럽트를 보내 알린다.

* 디바이스와 상호작용하는 방법
- port-mapped I/O  : 운영체제만 사용 가능한 특권 명령어와 장치를 구분하는 포트를 통해 장치의 레지스터에
  데이터를 직접 쓰거나 읽을 수 있도록 함
- memory-mapped I/O : 장치의 레지스터들이 마치 메모리 상에 존재하는 것처럼 함. 운영체제는 일반적 메모리
  load/store 명령어를 통해서 장치를 제어할 수 있게 됨
  
* 디바이스 드라이버 : 서로 다른 인터페이스를 갖는 장치들과 운영체제를 연결시키는 일방적인 방법, 최하위 
  계층에는 개별 장치와의 상호 작용을 위해선 각 장치의 입출력 명령어 형식을 정확히 이해하고 있는 소프트웨어가
  필요(추상화)
 
* 파일 시스템 
- 파일 시스템 소프트웨어 계층은 추상화가 어떻게 구현되어 있는지를 잘 보여줌
  > 파일 시스템 및 응용 프로그램은 현재 어떤 종류의 디스크를 사용하는지 전혀 모른다.
  > 범용 블럭 계층은 자신이 받은 요청을 적절한 디바이스 드라이버로 전달한다.
  > 디바이스 드라이버는 실질적인 디바이스 제어를 실행한다.
  
* 추상화의 단점
- 만약 특수 기능을 많이 가지고 있는 장치가 있다고 하더라도 커널이 범용적인 인터페이스만을 응용프로그램에
  제공할 경우, 이러한 기능들을 사용할 수 없게 된다.
- 어떠한 장치든지 디바이스 드라이버가 필요하므로, 운영체제가 지원하는 장치가 늘어남에 따라 디바이스 
  드라이버의 코드가 운영체제에서 차지하는 비중이 크게 늘었다.
  
* 하드 디스크 드라이버
- 하드 디스크는 지난 수십년간 컴퓨터 시스템에서 영속적인 데이터 저장을 위해 사용된 주요 매체이다.
  > 수 많은 섹터(최소 저장단위. 512 바이트의 블록)으로 구성됨
  > n개의 섹터로 구성된 디스크는 0~n-1 의 주소를 가진 섹터의 배열로 볼 수 있음
  > 데이터 읽기 및 쓰기 시 물리적인 움직임이 수반되며, 이로 인해 연속적 읽기/쓰기와 랜덤 패턴의 
  읽기/쓰기의 속도가 크게 차이난다.
  
* 하드 디스크의 구조
- 플래터 : 
  > 알루미늄으로 코팅된 얇은 자성 물질이 있는 원판
  > 데이터는 자서엧에 영구적으로 기록됨
  > 각 플래터는 두개의 면을 가지 ㅗ있으며 각각이 표면이라고 불림
- 축 :
  > 모터와 연결되어 플래터를 회전시킴
  > 회전 속도는 RPM으로 표시됨
- 트랙 : 
  > 섹터로 구성된 동심원
  > 데이터는 트랙의 각 표면에 저장된다.
  > 하나의 표면은 수천개의 트랙으로 구성된다.
- 디스크 헤드 :
  > 표면 하나당 하나의 헤드 존재
  > 읽기 및 쓰기는 헤드에 의해서 수행된다.
  > 하나의 디스크 암에 붙어있다.
  
* 단일 트랙 지연 시간 : 회전 지연
- 디스크에서 원하는 데이터를 읽기 위해선 헤드 아래에 원하는 데이터가 위치할 때까지 기다려야한다.
- 회전 지연 : 원하는 섹터가 회전하는데 걸리는 시간
  > 한바퀴를 다 회전하는데 걸리는 회전 지연을 R이라고 가정
    worst case : R-1

* 멀티 트랙 : 탐색 시간
- 좀 더 현실적인 디스크에는 트랙이 존재한다.
- 데이터를 읽거나 쓰기 위해서는 섹터 뿐 아니라 트랙을 올바르게 탐색해야만한다.
- 탐색 : 접근하려는 섹터를 포함하고 있는 트랙으로 디스크의 암을 옮기는 것, 디스크 연산에서 가장 오래
  걸리는 것 중 하나

* 탐색 과정 : 가속 -> 활주 -> 감속 -> 안정화
- 가속 : 디스크 암이 움직이기 시작
- 활주 : 디스크 암이 최고 속도로 움직임
- 감속 : 디스크 암이 느려지기 시작
- 안정화 : 정확한 트랙 위에 헤드가 조심스럽게 위치함

* 전송 : I/O의 마지막 과정, 표면에서 데이터를 쓰거나 읽는다.

* 그 외 세부 사항 
- 트랙 비틀림 : 트랙간에 섹터를 비틀리게 배치함으로써 연속적인 읽기가 효율적으로 동작하도록 함, 트랙 비틀
  림이 없다면, 헤드가 인저 트랙으로 이동했을 때, 원하는 블록이 이미 지나간 바람에 회전 지연이 크게 발생할 수 있음
- 멀티 구역 디스크 드라이브
  > 디스크들은 여러 구역으로 나뉘어 있으며, 한 구역은 표면 위에 연속적으로 존재하는 트랙의 집합
  > 각 구역 내 트랙은 같은 수의 섹터를 포함하고 있으며, 바깥쪽 구역의 트랙은 안쪽 구역의 트랙보다 많은
    수의 섹터를 가진다.
- 캐시 or 트랙 버퍼
  > 8~16MB의 작은 메모리로, 디스크에서 읽거나 쓴 데이터를 보관하여 이후 요청에 더 빠르게 반응
  > 쓰기의 경우 "완료 보고"는 다음과 같은 타이밍에 이루어 질 수 있음
    = 메모리에 쓰기가 완료되었을 때 -> write back
    = 실제 디스크에 쓰기가 완료되었을 때 -> write-through
  > write-back이 더 빠르지만, 정확한 순서가 중요할 때는 주의가 필요
