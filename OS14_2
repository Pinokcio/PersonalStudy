* I/O 시간 계산
- I/O time : T(i/o) = T(seek) + T(rotation) + T(transfer)
- The rate of I/O(Ri/o) = R(i/o) = Size(transfer)/T(i/o)
- 주요 I/O 연산으로는 랜덤과 순차가 있다.
ex) 랜덤 워크로드 : 4kb의 랜덤 데이터를 읽음 / 순차 워크로드 : 100mb의 연속 데이터를 읽음
  > 순차가 랜덤 대비 200~300배 가량 빠르다.
  
* 디스크 스케줄링
- 디스크 스케줄러
  > 어떤 I/O를 처리할지 결정
  > 각 작업의 길이가 얼마나 될지 알 수 없는 작업 스케줄링과 다르게 디스크 스케줄링의 경우 디스크 요청
    작업이 얼마나 길지를 꽤 정확히 예측 가능
  > 따라서 어떤 작업이 가장 빨리 끝날지 알 수 있으며, 이로 인해 SJF(shortest job first)의 원칙을 
    따르려고 노력하게 된다. 
    
* SSTF(Shortest Seek Time First)
- 트랙을 기준으로 I/O 요청 큐를 정렬하여 가장 가까운 트랙의 요청이 우선 처리되도록 한다.
- 문제 1
  > 운영체제는 디스크의 내부 구조를 알지 못한다.
  > 이를 해결하기 위해 운영체제는 NBF방식을 사용(가까운 블록이 접근 트랙에 있을 것이다.)
- 문제 2
  > 현재 헤드와 가까이 있는 요청만 처리하게 될 경우 먼 곳을 접근하는 요청이 처리되지 않는 기아 문제 발생
  
* 엘리베이터(SCAN or C-SCAN)
- 트랙의 순서에 따라 디스크를 앞뒤로 가로지르며 요청을 처리
- F-SCAN : 디스크를 sweep 하는 동안에 새로운 요청이 도착하면 다음 번 서비스 될 큐에 삽입하여 인접한 요청
  들만 처리되는 것을 방지
- C-SCAN : 디스크를 한 방향으로만 sweep하는 것이 아니라 안->밖, 밖->안 순으로 sweep 함
- 엘리베이터의 움직임과 유사하다 하여 엘리베이터라고 불림(SJF의 철학을 따르지 않으며 디스크의 회전 또한
  고려하지 않음)
  
* I/O 병합
- 디스크 요청을 재배치 하여 디스크에 보내는 요청의 수를 줄임으로써 오버헤드를 줄임
ex) 33,8,34 번 블록을 읽어야 할 경우 -> 스케줄러는 33,34를 병합으로 처리한다.

* RAID
- RAID는 여러 개의 디스크를 조화롭게 사용하여 이를 달성한다.
- 디스크 여러개를 병렬적으로 사용하여 I/O 시간 개선
- 데이터 중복 기술을 통해 일부 디스크의 고장을 극복할 수 있다.

* RAID의 평가 방법
- 용랑(capacity) : B개의 블록을 가지는 N개의 디스크가 주어졌을 때 RAID 클라이언트의 유효 사용 용량은?
  중복이 없으면 N*B, 미러링의 경우엔 (N*B)/2
- 신뢰성(reliablity) : 몇 개의 디스크 결함을 감내할 수 있는가?
- 성능(performance)

* RAID 레벨 0 : 스트라이핑
- 중복저장을 하지 않는다.
- round robin 방식으로 디스크들에 걸쳐서 저장
- 성능과 용량에 대한 상한 기준이 됨
- 청크 크기는 RAID의 성능에 큰 영향을 준다.
  작은 청크 > 여러 디스크에 걸쳐 스트라이프 됨
    > 병행성 증가
    > 찾기 시간 증가
  큰 청크 > 파일 내 병렬성 줄어듦
    > 찾기 시간 감소
- 용량 : 완벽(N*B)
- 신뢰성 : 최악, 하나의 디스크라도 고장나면 전체 데이터가 손실
- 성능 : 훌륭, 모든 디스크가 병렬로 사용됨

* RAID 레벨 1 : 미러링
- 각 블록에 대해 하나 이상의 사본을 둔다
- 각 사본은 서로 다른 디스크에 저장된다.
- 용량 : 비싸다 (N*B)/2
- 신뢰성 : 괜찮은 편이다. 어느 것이 고장나도 감내할 수 있다.
- 성능 : 단일 읽기, 단일 쓰기에 대해선 괜찮지만 다수 디스크에 대한 쓰기는 최악이다

* RAID 레벨 4 : 패리티를 이용한 공간 절약
- 패리티 기반의 접근 방법은 미러링 시스템의 엄청난 공간 낭비를 극복하는 것이 목적이며, 대신 성능 저하가 
  발생한다.
- 스프라이트마다 해당 스프라이트에 대한 중복 정보를 담고 있는 패리티 블록을 추가
- 패리티 계산 : XOR 사용
- 용량 : 패리티를 위해 디스크 하나를 사용해야 하므로 (N-1)*B
- 신뢰성 : 하나의 디스크 고장만 감내 가능
- 성능 : 단일 쓰기에 대한 성능이 안좋음.
- 랜덤 쓰기를 할 경우 패리티가 깨지는 문제 발생 
  > 가산적 패리티 or 감산적 패리티를 통해 해결
- small-write 문제 : 패리티 디스크가 전체의 병목을 일으킬 수 있음 why? 패리티 디스크는 병렬적으로 접근
  할 수 없고 순차적으로 접근해야만 하기 때문
  
* RAID 레벨 5 : 순환 패리티
- small-write 문제에 대한 해결책 제시
- RAID 4와 비교하여 패리티 블록을 순환시킨다는 점이 다름 -> 병목 현상 제거
- 용량 : (N-1)*B
- 신뢰성 : 하나의 디스크 고장만 감내 가능
- 성능 : RAID 4에 비해 랜덤 읽기(모든 디스크 사용 가능)와 랜덤 쓰기 성능이 더 좋아짐

* RAID 요약
- 성능을 우선시하고, 신뢰도는 무시한다 -> RAID 0
- 랜덤 I/O 성능과 신뢰도를 추구한다 -> RAID 1
- 용량과 신뢰도를 추구한다 -> RAID 5
- 연속 I/O와 용량 극대화를 추구한다 -> RAID 5
