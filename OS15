* 영속 저장 장치 (Persistent Storage)
- 전원이 나가더라도 데이터를 영구적으로 보존한다.
- 하드디스크, SSD 등이 대표적이다.
- 저장장치의 가상화에 대한 두 가지 주요 개념
  > 파일(File)
  > 디렉토리(Directory)
  
* 파일
- 순차적인 바이트의 배열
- inode 번호라고 불리는 저수준의 이름을 가지고 있다.
  > 유저에게는 드러나지 않는다.
- 운영체제 (즉, 파일시스템)의 역할은 데이터는 디스크에 안전히 저장하고, 데이터가 요청되면 처음 저장했던 
  데이터를 돌려주는 것
  > 운영체제에게 데이터의 종류(e.g. 소스코드, 이미지, 음악 파일 등)는 중요한 것이 아니다.
  
* 디렉토리
- 디렉토리 또한 파일과 마찬가지로 저수준의 이름(아이노드 번호)를 가진다.
- 그러나, 파일과 달리 디렉토리의 내용은 구체적으로 정해져있다.
- 디렉토리는 <사용자가 읽을 수 있는 이름, 저수준의 이름>쌍으로 이루어진 목록을 가지고 있다.
  > e.g. ("foo", "10")
  > 이러한 목록의 각 항목들은 다른 디렉토리나 파일을 가리킨다.
  
* 디렉토리 트리(디렉토리 계층)
- 디렉토리 내에 다른 디렉토리를 포함함으로써 사용자는 모든 파일 및 디렉토리의 관계를 트리 형태로 구성할 수
  있다.
  
* 파일의 생성
- open() 시스템 콜을 O_CREAT 플래그와 함께 실행
  > int fd = open("foo", O_CREAT | O_WRONLY | O_TRUNC);
                         파일 생성, 쓰기 전용, 기존 파일 지우고 크기를 0
- open() 시스템 콜은 파일 디스크립터를 반환한다.
  > 프로세스마다 존재하는 정수로서 open된 파일을 읽고 쓰는데 사용된다.
  > 파일 객체에 대한 포인터로 볼 수도 있음
    
* 비 순차적 읽기와 쓰기
- 운영체제는 open()한 각 파일에 대해 현재 오프셋을 추적하여 다음 읽기 또는 쓰기 위치를 결정한다
  > 커널 파일 구조체에서 오프셋을 저장
- 오프셋은 두가지 방법으로 갱신된다.
  > N바이트를 읽거나 쓰면 현재 오프셋에 N이 더해진다.
  > lseek()을 이용한다. - off_t lseek(int fildes, off_t offset, int whence);
                                      파일 디스크립터, 위치 오프셋, lseek 동작 방식

* fsync()를 이용한 즉시 기록
- write()의 목적은 대부분 해당 데이터를 영속 저장장치에 기록해 달라고 파일 시스템에 요청하는 것이다.
  > 그러나, 성능상 이유로 운영체제는 해당 요청등을 일정 시간동안 버퍼링 한 후, 일괄적으로 저장 장치에
    전달한다.
  > 따라서, write()를 호출했지만 디스크에 쓰기 전에 시스템이 다운되는 경우 데이터가 유실될 수 있다.
- 그러나 DBMS의 데이터 복원 모듈들과 같이 어떤 프로그램은 강제적으로 즉시 디스크에 데이터를 쓰고 싶을  
  수 있다.
- off_t fsync(int fd)
  > 특정 파일 디스크립터에 대해 모든 dirty를 디스크로 강제로 내려보내고, 쓰기가 완료되면 리턴한다.
  
* 파일 이름 변경
- rename(char * old, char * new)
  > 파일 이름을 새로운 이름을 ㅗ변경
  > 만약 새로운 파일 이름이 이미 존재한다면, 해당 파일은 교체된다.
  > 원자적으로 동작한다.
  
* 파일 정보 추출
- stat(), fstat() : 파일의 메타데이터를 보여준다
  > 메타데이터란, 파일시스템이 각 파일에 대해 관리하는 정보이다. 
  ex) 크기, 저수준 이름, 소유권, 접근 시간 등
  > 커널은 메타데이터를 inode 자료구조 내에세 관리한다.
  
* 파일 삭제
- 리눅스에서 파일 삭제를 위해서 rm을 사용한다.
- rm은 내부적으로 unlink()라는 시스템 콜을 사용한다.
  > delete나 remove가 아닌 unlink라는 이름을 사용한 것은 디렉토리와 관련이 있다.
  
* 디렉토리 생성
- 디렉토리 관련 시스템 콜은 디렉토리를 생성하고, 읽고, 삭제한다.
  > 디렉토리는 파일시스템의 메타데이터로 분류되며, 절대로 직접적으로 쓸 수 없으며, 간접적으로만 변경된다.
  > 가령, 디렉토리 내에 다른 파일이나 디렉토리를 만드는 방식으로 디렉토리의 내용이 간접적으로 바귄다.
- mkdir() : 디렉토리를 만드는 시스템 콜
  > 디렉토리가 만들어지면 빈 상태이지만, 아주 기본적인 두 개의 항목이 들어있다.
    > .(dot) : 현재 디렉토리
    > ..(dot-dot) : 자신의 부모 디렉토리
    
* 디렉토리 읽기
- ls 명령어는 디렉토리를 읽고 그 결과를 출력해준다.
- 디렉토리 스트림에 나열되어 있는 각 디렉토리 항목에 대한 정보는 struct dirent에 저장된다.
- 비교적 간단한 내용만 존재하며, ls -l과 같은 더 다양한 정보를 원할 때에는 stat()을 이용하게 된다.

* 디렉토리 삭제하기
- rmdir과 같은 명령으로 디렉토리를 삭제할 때는 rmdir()이라는 시스템 콜이 이용된다.
  > 디렉토리 삭제는 매우 위험한 작업이다.
  > 따라서 디렉토리가 비어있지 않다면, 삭제가 되지 않는다.
- rm -rf은 디렉토리가 비어 있지 않아도 삭제가 된다.
  > 디렉토리 내 모든 파일에 대해 unlink를 수행한 후, 마지막으로 디렉토리에 대해 rmdir을 하게 된다.
  
* 하드 링크 (Hard link)
- 파일 삭제 시 왜 unlik를 사용하는가?
- 파일 시스템 트리에 항목을 추가하는데 link() 시스템 콜이 사용된다.
- link(old pathname, new one)
  > 새로운 파일 이름을 이전 이름에 연결(link)하여 동일한 파일을 접근할 수 있는 새로운 방법을 만든다
  > shell에서는 ln 명령어가 이와 관련된다.
- link()는 새로이 링크하려는 이름 항목을 디렉토리에 생성하고, 원래 파일과 동일한 아이노드 번호를 
  가리키도록 한다.
    > 이를 통해 파일을 복사하지 않고도 동일한 파일을 가리키게 된다.
- ls -i를 통해 각 파일의 아이노드 번호를 확인해볼 수 있다.
- 파일을 생성한다는 것은
  1. 파일 관련 거의 모든 정보를 관리하는 자료구조인 아이노드를 만드는 것이다.
  2. 해당 파일에 사람이 읽을 수 있는 이름을 연결하고, 극 연결정보를 디렉토리에 생성하는 것
- link()를 통해서 만들어진 두 파일 이름은 모두 동일한 아이노드에서 찾을 수 있는 파일의 메타데이터에 대한
  연결이다.
- unlink()를 통해 파일을 삭제하는 것은
  > 해당 아이노드 번호에 대한 참조횟수(reference count)를 줄이는 것이다.
  > 만약 참조 횟수가 0이 되면, 파일 시스템은 실제로 아이노드와 관련된 데이터 블록을 해제하여 파일을
    진정으로 삭제한다.
    
* 심볼릭 링크 (Symbolic link)
- 하드 링크와 관련되기 때문에 소프트 링크라고도 부른다.
- 하드 링크는 제약이 많다.
  > 디렉토리에 대해서는 하드 링크를 만들 수 없으며
  > 다른 디스크 파티션에 있는 파일에 대해서도 하드 링크를 걸 수 없다.
    - 아이노드는 하나의 파일 시스템 내에서만 유일하기 때문
- 심볼릭 링크는 ln -s를 통해 만들어진다.
- 심볼릭 링크는 파일, 디렉토리에 이은 파일 시스템의 세 번째 유형이다.
- ls -al을 통해 살펴보면 하드링크와 명확히 차이가 난다.
  > 원본 파일과 완전히 동일한 하드링크와 다르게, 심볼릭 링크는 
    = 파일의 크기가 원본과 달리 4bite이다. (파일의 경로명 저장 및 가리키는 대상 표시)
    = ls -al결과의 맨 왼쪽에 l이라고 표시(d는 디렉토리, -는 파일)
- 가리키는 파일의 경로명이 길어질 경우 심볼릭 링크의 크기가 커질 수 있다.
- 가리키는 방식의 특성으로 인해 원본이 삭제 되었을 때, dangling reference가 발생할 수 있다.

* 파일 시스템 생성과 마운트
- 다수의 파일 시스템이 존재할 때, 이들을 묶어서 하나의 큰 디렉토리 트리로 표시할 수 있다.
- mkfs라는 도구를 이용해 파일 시스템을 생성할 수 있다.
  > 입력 : 장치명(디스크 파티선, /def/sda1), 파일 디스크 타입(ext3, ext4)
  > 입력이 들어오면, 해당 파티션에 전달된 파일 시스템의 형식으로 구성된 빈 파일 시스템을 생성
    = 생성된 파일 시스템은 자체적인 디렉토리 구조로 구성된다.
    = 최초에는 비어 있기 때문에 루트 디렉토리만 존재한다.
- 어떠한 파일 시스템을 루트 디렉토리부터 시작하는 기존의 디렉토리 구성을 통해 접근하도록 하는 것은
  mount라는 도구를 이용해 가능하다
- mount()
  > 기존 디렉토리 중 하나를 마운트 지점으로 지정
  > 해당 마운트 지점에 파일 시스템을 붙여 넣는다.
ex) mount -t ext3 /dev/sda1 /home/users (ext3종류의 /dev/sda1이라는 파일 시스템을 /home/users에 마운트)
- mount 프로그램을 실행하면 어떤 파티션들이 어디에 마운트 되어있는지 확인할 수 있다.
