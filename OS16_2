* 크래시 일관성
- 여타 자료구조와 달리, 파일 시스템 자료구조는 안전하게 유지되어야 한다.
- 파일 시스템의 가장 큰 어려움은, 어떻게 전력 손실이나 시스템 크래시가 발생하는 상황에서도 안전하게 디스크
  상의 내용을 갱신하는가이다.
- 크래시 일관성 문제
  > 특정 작업을 위해 디스크 상에서 두 개의 자료구조 A,B를 갱신한다고 가정
  > 디스크는 한 번에 하나의 요청만 처리 가능하기 때문에 둘 중 하나만 먼저 도착할 것이다.
  > 이후, 하나의 쓰기 작업만 완료한 상태에서 시스템 전원이 나갈 경우, 디스크 상의 자료구조는 일관성이
    깨지게 된다.
  > 이러한 문제를 해결할 수 있어야 한다.
    = fsck(file system checker)
    = journaling(write-ahead logging, WAL)
    
* 크래시 일관성 문제
- 갑작시런 크래시 발생으로 파일 시스템 자료구조 간의 불일치, 공간 누수, 쓰레기 데이터 등 여러문제가 발생 
  할 수 있다.
- 이를 해결하기 위해선 연산 이전의 상태에서 연산 이후의 상태로 이동할 때
  => 중간의 임시 상태로 파일 시스템이 남아있는 것을 방지해야 한다.

* 해법 1 : 파일 시스템 검사기
- 파일 시스템 검사기 (File System Checker, fsck)
  > 파일 시스템 일관성 문제를 그대로 두었다가 리부팅 시에 문제를 해결
  > fsck는 일관성 불일치를 발견하고 수정하는 UNIX도구이다.
  > 단, fsck는 메타데이터의 일관성 불일치만을 해소한다.
  > fsck는 파일 시스템이 마운트 되기 직전에 실행된다.
  > fsck는 슈퍼블록, 프리블록, 아이노드 상태, 아이노드 링크 등을 체크한다.
- 문제점 
  > fsck를 만드는 것은 파일 시스템에 대한 전반적 이해가 필요하다.
  > 너무 느리다
  > fsck는 일부에 문제가 생겼을 경우에도 전체를 검사해야 한다는 단점이 있다.
  
* 해법 2 : 저널링 (Journaling)
- 저널링(또는 write-ahead logging, WAL)
  > 데이터베이스 관리 시스템에서 차용한 개념
  > 리눅스의 ext3, ext4, 윈도우의 NTFS등이 이를 사용하고 있다.
  > 방법
    - 디스크 내용을 갱신할 때, 해당 자료구조를 갱신하기 전, 수행하고자 하는 작업을 요약해서 기록해준다.
    - 이후, 디스크를 갱신하는 과정에서 크래시가 발생하면, 로그를 확인하여 다시 갱신한다.
    - 결과적으로 크래시가 발생해도 디스크 전체를 다 스캔하지 않아도 선택적으로 문제를 해결할 수 있다.
    - 쓰기 시 약간의 오버헤드가 발생하지만, 의외로 작으며 시스템 복구 성능을 대폭 개선하기에 대부분의
      파일 시스템에서 사용된다.
- TxB : 트랜잭션 시작 블록
  > 갱신될 블록들에 대한 정보
  > TID(transaction identifier)
- 갱신될 데이터 및 메타데이터 블록
  > 디스크 상의 최종 위치에 기록될 내용들이 저장
  > 물리적 내용을 기록하므로 물리 로깅이라고 불림
  > 혹은 명령어 자체를 저장하는 논리 로깅도 존재
- TxE : 트랜잭선 종료 블록
  > 트랜잭션의 끝을 알림
  > TID 포함
  > 이 블록이 로그에 기록되면 해당 트랜잭션은 커밋되었다고 말한다.
- 체크포인트
  > 저널에 기록된 내용을 실제 위치에 반영하는 과정
    1. 저널 기록 (트랜잭션을 저널에 기록, 트랜잭션이 디스크에 안전하게 기록될 때까지 대기)
    2. 체크포인트 (갱신된 메타데이터 및 데이터 블록들을 해당 위치에 반영)
    
* 데이터 저널링
- 저널에 기록하는 도중 크래시가 발생한다면 어떻게 될 것인가
  > 트랜잭션에 속한 블록 집합을 디스크에 기록하는 간단한 방법은 각각 트랜잭션(TxB, I[v2], B[v2], Dnb, Txe)
    를 하나하나 순차적으로 저장하는 것이나 시간이 너무 오래걸린다.
  > 트랜잭션 블록을 한 번에 저장한다면 다섯개의 쓰기가 하나의 연속 쓰기가 되므로 빨라지지만 안전하지 않다.
  > Txb, I[v2], B[v2], Txe 쓰기와 Db 쓰기로 나누면 트랜잭션은 정상 종료되더라도 Db에 쓰레기 값이 들어갈
    수 있다.
- 이런 문제를 막기 위해 파일 시스템은 트랜잭션을 두 단계로 나누어 기록한다.
  > TxE를 제외한 모든 블록을 한 번의 쓰기 요청으로 수행
  > 이후 TxE에 대한 쓰기를 요청하여 저널을 최종적이고 안전한 상태로 만든다.
  > TxE는 무조건 원자적으로 기록되어야 한다.
- 전체 과정은 다음과 같다
  1. 저널 쓰기 : 트랜잭션의 내용을 로그에 쓰고 완료되기를 기다린다.
  2. 저널 커밋 : TxE를 로그에 쓴다.
  3. 체크포인트 : 갱신한 내용을 디스크 상의 최종 위치에 쓴다.
  
* 복구
- 크래시 상황에서 저널을 이용하여 파일 시스템을 복구
  > 트랜잭션이 안전하게 저장되기 전에 크래시가 나면 아무것도 하지 않는다.
  > 체크포인트가 완료되기 전에 크래시가 발생한다면
    1. 복구 프로세스는 시스템이 부팅할 때 로그를 탐색하여 디스크에 커밋된 트랜잭션이 있는지 파악
    2. 커밋된 트랜잭션의 블럭들을 재생하여 디스크 상의 원래의 위치에 기록
    3. 복구 후 파일 시스템을 마운트한다.
      
* 로그 공간의 관리 
- 로그의 크기는 정해져 있다
  > 로그가 가득차면 두 가지 문제가 발생한다.
    1. 모든 트랜잭션을 순서대로 재실행해야하기 때문에 복구 소요 시간이 길어진다.
    2. 로그가 가득찼다면 더 이상의 트랜잭션을 커밋할 수 없게 된다.
  > 이를 해결하기 위해 로그를 환형 자료구조 형식으로 사용한다.
    - 따라서 저널은 때로 환형 로그라고 불린다.
    - 구현하는 한 가지 방법은 <최신 트랜잭션의 위치, 가장 오래된 트랜잭션의 위치>를 저널 슈퍼블록에 
      기록해 놓는 것이다.
        
* 메타 데이터 저널링
- 데이터 저널링은 두 번씩 쓰기가 이루어져야하므로 느리며 내용을 파일 시스템에 기록하기 위한 탐색 시간도 
  추가된다.
- 데이터 저널링은 모든 데이터 (데이터+메타데이터)를 함께 저널링했다.
- 메타데이터 저널링은 효율성을 위해 데이터 블록에 대해 저널링을 하지 않는다.
- 메타데이터 저널링에서는 데이터 블록을 저널에 기록하지 않는다
- 데이터 블록은 곧바로 최종 위치에 기록된다.
  > 여전히 메타데이터는 두 번 쓰기를 해야하지만, 트래픽의 대부분을 차지하는 데이터 블록에 대해 쓰기 중복
    을 없애게 된다.
- 데이터 블록이 디스크에 쓰여지는 타이밍은 크래시 일관성에 중요하지 않으므로 일관성에 대해 좋은 성능을
    가짐
1. 데이터 쓰기 : 데이터를 최종 위치에 쓴다
2. 저널 메타데이터 쓰기 : 시작 블록과 메타데이터를 로그에 쓴다
3. 저널 커밋 : TxE를 포함한 트랜잭션 커밋 블록을 로그에 쓰고, 쓰기가 완료될 때까지 기다린다.
4. 체크포인트 메타데이터 : 갱신된 메타데이터의 내용을 파일 시스템 상에 있어야 할 최종 위치에 갱신한다.
5. 해제 : 저널 슈퍼블록에 해당 트랜잭션이 해제되었다고 표기한다.

* 까다로운 사례 : 블록 재활용
- 블록을 재활용하게 되면 크래시가 발생했을 때, 재활용되기 이전의 로그 값에 대해 복구가 진행될 수 있기
  때문에 문제가 된다.
@ 해결책 : 
  > 지워진 블록이 체크포인트 될 때까지 절대로 재사용하지 않는다.
  > 철회 레코드라는 항목을 추가하여 기록한다.
  > 디렉토리를 삭제하면 저널에 철회 레코드를 기록하도록 하고, 복구 과정에서 시스템은 먼저 철회 레코드를
    탐색하고, 철회된 내용은 재실행 하지 않도록 한다.
      
