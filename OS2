// 프로세스
- 프로그램 : 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음
- 프로세스 : 실행중인 프로그램
- 운영체제는 cpu를 가상화하여 프로세스들이 각각의 cpu 위에서 동작하는 것처럼 만듦 -> 시분할 기법 사용
  # 각각의 프로세스가 짧은 시간 동안 돌아가면서 물리적 cpu에서 동작하도록 함
  # 스케줄링 정책
    * 이전 수행 정보
    * 어떤 유형의 프로그램들이 실행되었는가
    * latency를 줄여야 하는가
    
// 스케줄링
- 어떠한 정책을 통해 수 많은 프로세스 중 어떤 프로세스를 실행해야 할지를 결정.
- 과거정보 이용
- 워크로드에 대한 지식 (어떤 유형의 프로그램들이 실행되었는지)
- 성능 측정 결과 : 시스템의 latency를 줄여야하는지 혹은 시스템의 throughput을 높여야 하는지
- 문맥 교환 (context switch) : 실행될 프로세스가 결정되면 이전 프로세스는 내려오고 새 프로세스가 올라감

! 프로세스와 프로그램의 가장 큰 차이는 Run-time state의 존재 유뮤이다
  - run-time state는 메모리, cpu의 레지스터 등에 저장됨
  - program-counter
  - stack pointer / frame pointer : 현재 스택의 위치 (top)

// 프로세스 생성 과정
1. 운영체제가 프로그램을 load 할 메모리 확보
2. 운영체제는 프로세스의 디스크에 파일 형태로 존재하는 code 및 static data를 프로세스 메모리에 laod한다.
  (on demand 형태로 load 함)
3. 운영체제는 프로세스의 run-time stack(지역 변수, 함수 매개변수, 리턴 주소)을 위한 메모리 확보
4. 운영체제는 프로세스의 heap을 위한 메모리 확보(c에서는 malloc, free / c++에서는 new, delete를 통해 할당/해제)
5. 운영체제는 I/O와 관련된 초기화 작업 또한 수행 (기본적으로 세 개의 file descriptor를 할당, 입력/출력/에러)
6. 프로그램의 entry point부터 프로세스를 시작한다.

// 자료구조
- PCB : 프로세스 ID, 상태, 자원, Context 등을 저장
- PCB들은 Process list에 의해 관리됨 (Ready, Block, Running 프로세스들을 List 형태로 관리)

// 프로세스 API
- fork() : 자식 프로세스 생성
- exec() : fork()를 통해 생성해낸 자식 프로세스에서 인자로 쓰인 프로그램을 실행
- wait() : 자식 프로세스가 종료될 때까지 프로세스 대기
- 좀비 프로세스 : 자식 프로세스는 종료 시 코드/데이터 등의 메모리는 제거가 되나 프로세스 상태는 남겨둠
- 고아 프로레스 : 자식 프로세스 이전에 부모 프로세스가 종료될 경우 해당 자식 프로세스를 지칭함

// redirection : file description을 재지정하여 원하는 곳에 결과값을 출력하도록 한다.

// cpu 가상화 
- 직접 실행 : 프로그램을 빠르게 실행하기 위해 프로그램을 cpu 상에서 직접 실행시킴, 간단하고 빠르지만
  운영체제의 보안상 측면에서 단점을 가짐.
- 간접 실행 : 사용자모드와 커널모드를 나눔으로써 기능상, 보안상에 차이를 둔다.
  사용자 모드에서도 프로세스가 하드웨어 리소스에 접근할 수 있도록 운영체제는 프로세스에 시스템 콜을 제공함

// 시스템 콜 동장
- 프로세스가 시스템 콜을 호출하면 trap 명령어를 통해 유저 모드에서 커널 모드로 실행 권한이 올라간다.
  (프로세스의 레지스터들이 커널 스택에 백업 되어야 함)
  해당 시스템 콜을 처리한 후 return-from-trap 명령어를 통해 실행 권한은 다시 유저 모드로 내려간다.
  (커널 스택에 백업해 두었던 프로세스의 레지스터가 모두 복원됨)

// 커널 스택
- 프로세스는 생성 될 때, 두 개의 스택을 만든다 ( 1. 유저 모드 스택, 2. 커널 모드 스택 )
  -> 멀티 프로세스 환경에서는 여러 프로세스가 동시에 커널을 이용하게 되는데 이 때 하나의 스택으로는 수용 불가능 하기 때문

// 프로세스 간 스위칭
- 협조 방식 : 프로세스가 cpu를 완전히 점유, 제어권을 스스로 운영체제에게 넘겨야 함, 악의적으로 사용 가능
- 비협조 방식 : 운영체제가 프로세스로부터 cpu 제어권을 강제로 빼앗아옴, 타이머 인터럽트를 사용하여 일정시간마다
  스케줄링 정책을 적용하여 다음 실행 할 프로세스를 결정함
- 스케쥴러 : 커널은 타이머 인터럽트 혹은 프로세스의 협조를 통해 제어권을 얻음.
  이후 스케쥴러를 통해 현 프로세스를 지속할지 다른 프로세스를 실행할지 결정.
  다른 프로세스를 실행하기로 결정할 경우, 문맥 교환 (Context-Switch)를 수행
  이후 커널에서 return-from-trap을 수행하면 기존 프로세스가 아닌 새로운 프로세스로 리턴하게 됨
  
  
 // 병행성 문제
 - 인터럽트나 trap handling을 하는 동안 또 다른 interrupt가 발생하지 않도록 인터럽트를 비활성화하거나
   "lock" 기법을 도입하여 서로 다른 두 개의 문맥에서 동일 커널 자료구조에 접근하는 것을 막는다.
   -> 단점 : 커널의 구조가 복잡해 질 수 있으며 찾기 어려운 버그가 발생할 수 있음
