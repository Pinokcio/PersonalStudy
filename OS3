* 스케줄링
- 운영체제에서 멀티 프로세스들이 어떻게 CPU를 Time-sharing하도록 할 것 인가.
- 다양한 스케줄링 정책의 당위성을 살펴보기 위해, 멀티 프로세스들이 동작하는 워크로드에 대해 
  비현실적 가정을 하고 완화해 나가도록 한다.
  1. 모든 작업은 같은 시간 동안 실행된다.
  2. 모든 작업은 동시에 도착한다.
  3. 각 작업은 시작되면 완료될 때까지 실행된다.
  4. 모든 작업은 CPU만 사용된다. (입출력x)
  5. 각 작업의 실행 시간은 사전에 알려져 있다.
  
* 선입선출(FIFO)
- '선도착처리'라고도 함
- 문제점 :
  "모든 작업은 같은 시간 동안 실행된다" 완화
  -> Convoy effect : 짧은 시간 동안 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세스의
  종료를 기다림
  
* 최단 작업 우선(SJF)
- 짧은 실행 시간을 가진 작업부터 실행 -> Convoy effect 해소
- 문제점 :
  "모든 작업은 동시에 도착한다" 하에서만 최적
  완화할 경우 짧은 실행 시간을 가진 작업이 더 늦게 도착할 경우 (FIFO)와 같은 맥락의 문제 발생
  -> "각 작업은 시작되면 완료될 때까지 실행된다"를 완화하고, 선점형(비협조형)으로 동작하는 운영체제를 통해 
  프로세스를 강제로 중단시키고 context switching 시킴으로써 해결한다.
  // 선점형 운영체제 : 선점형 스케줄러를 사용함으로써 프로세스의 실행에 강제로 개입이 가능하다.
  // 많은 최신 운영체제는 선점형 운영체제 + 선점형 커널이다.
  
* 최소 잔여시간 우선(STCF)
- SJF에 선점성을 추가(선점형 SJF > PSJF로도 불림)
- 새로운 작업이 들어오면, 현재 실행중인 작업과 새로운 작업의 잔여 시간을 비교하여, 가장 작은 잔여 시간을 
  가진 작업을 스케줄한다.
  
* 라운드 로빈 스케줄링(RR)
- 스케줄된 작업을 단위 시간 동안만 실행하고 실행 큐의 다음 작업으로 전환한다.
> 단위 시간 : 타임 슬라이스, 스케줄링 퀀텀
- 매 time slice마다 작업 전환(context switching)이 일어난다.
  = context switching은 비싼 연산이다.
  = time slice는 최소 context switching 시간보단 길어야하며, time slice가 짧을 수록 context switching
    오버헤드가 상대적으로 커질 것이다.
  = time slice를 길게 가져갈수록 context switching 오버헤드는 작아지지만, 응답시간에는 불리하다.
- RR 스케줄링은 응답 시간은 좋지만, 반환 시간이 좋지 않다.

* 입출력 연산의 고려
- "모든 작업은 CPU만 사용한다"를 완화하여 입출력 또한 수행한다고 가정
- 스케줄러는 시스템콜 호출을 통해 입출력의 시작, 인터럽트를 통해 입출력의 끝 부분을 알 수 있다.
- 프로세스가 다른 프로세스에게 CPU 점유권을 넘겨줬을 때 입출력을 수행하도록 스케줄링 하면 
  CPU Utilization을 높일 수 있다.
  
* 멀티 레벨 피드백 큐(MLFQ)
- "각 작업의 실행 시간은 사전에 알려져 있다"를 완화
- 기본적으로 운영체제는 현재 실행중인 작업이 언제 끝날 지 알 수 없기때문에, 최적화된 스케줄링을 위해서
  해당 작업이 지금까지 보인 특성을 기반으로 적절한 스케줄링 정책을 적용시켜줘야 한다.
- 목적 : 
  - 짧은 작업을 먼저 실행하여 반환 시간 최적화
  - 응답 시간을 최적화하여 대화형 작업에 적합하도록 함
  - 반환 시간과 응답 시간이 양립하도록 해야함
- 문제점 :
  1. 기아상태 : 너무 많은 대화형 작업들이 있을 경우 우선순위가 낮은 CPU 위주 작업은 실행되지 않는다.
  2. 악의적 스케줄링 : time slice를 알고 있는 공격자가 99%를 사용하고, 입출력 연산을 수행하면 CPU를 독점
  할수 있게 된다.
  3. 프로그램 상태 변화 : 많은 프로그램에서 실행 중 특성이 바뀔 수 있지만 이 부분은 예측하기 힘들다.
  
  * 비례 배분 스케줄링
  - 공정 배분이라고도 한다.
  - 반환 시간이나 응답 시간과 같은 성능 위주가 아닌 각 작업이 CPU를 일정한 비율로 사용할 수 있도록 보장
    하는 공정성에 초점을 둔다.
  - 추첨권(Ticket) : 프로세스가 받아야 하는 자원의 비율을 나타내는데 사용
  
  * 추첨 스케줄링
  - 매 time slice가 끝날 때마다 추첨을 통해 어떤 프로세스가 실행될지를 추첨권을 통해 확률적으로 결정
  - 큰 수의 법칙에 따라 추첨권에 따른 비율을 반영하게 된다.
  - 구현이 단순하다는 장점
  
  * 멀티 프로세서 스케줄링의 어려움
  - 멀티 프로세서라고 해서 프로그램의 실행속도가 빨라지지는 않음
  - 수 많은 스레드를 성능 효율적으로 스케줄링 해야함
  
  * 단일 프로세서 구조
  - CPU
  - Cache : 작고, 빠른 메모리 / 메모리에서 접근되었던 데이터를 임시저장 / 시간, 공간 지역성에 기반하여 성능 향상
  - Main Memory : 데이터 보관 / 보통 가격이 저렴하고 대용량인 DDR RAM 사용
  
  * Cache
  - Cache Hit은 상당한 성능 이점을 가져옴
  - Cache를 끌 경우, 프로그램의 성능은 10배 이상 느려질 수 있다.
  - 캐시 일관성은 안전한 성능을 보장하기 위해 유지되어야 하는 중요한 요소
    = 버스스누핑 : 각각의 캐시가 캐시-메모리 버스를 감시하여 하나의 캐시에 대한 변경이 발생하면, 
      모든 캐시가 이를 인지할 수 있도록 한다.
    = Cache coherence 문제가 해결된다고 해도 멀티프로세서에서는 동기화 문제가 발생한다.
      > 결국 CPU는 데이터를 register에 로드한 후 연산하기때문.
      > lock과 같은 운영체제 차원의 동기화를 위한 지원이 필요하다.
      
  
