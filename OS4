* 메모리 가상화
- 운영체제는 물리메모리를 가상화하고, 각 프로세스에 가상 메모리 공간을 제공한다.
- 결과적으로, 각 프로세스는 모든 메모리를 혼자 사용하는 것과 같은 효과를 얻게 된다.
- 이점 : 
  1. 프로그램은 언제나 동일하고 충분한 메모리 공간에서 실행될 것임을 가정할 수 있으므로 프로그래밍이 간단해진다.
  2. 각각의 프로세스들이 상호간에 고립되어 보안성이 향상된다.
  
* 주소공간
- 운영체제는 프로그래머가 사용하기 쉽도록 주소 공간이라는 개념을 도입
- 코드 : 프로그램의 명령어들
- 힙 : malloc / new 등에 의해 동적으로 할당된 메모리
- 스택 : 프로세스의 콜스택을 저장, 지역변수/return주소/리턴 값 등이 저장
- 데이터 : 정적으로 포함된 데이터, RO / RW / BSS(초기화되지 않은 데이터 영역)
- CPU 상에서 프로세스는 가상 주소를 기반으로 수행된다.
- 가상 주소는 실제 메모르에 접근할 때만 하드웨어의 지원(MMU)의 도움을 받아 물리주소로 변환된다.

* 메모리 가상화의 고려사항
- 투명성 : 프로그램은 가상 메모리의 존재를 인지하지 못해야 한다. 즉, 프로그램은 자신의 전용 물리 메모리를
  소유한 것처럼 동작할 수 있어야 한다.
- 효율성 : 메모리 가상화가 시간 및 공간 면에서 효율적이어야 한다.
- 보호 : 각 프로세스들을 고립함으로써 프로세스간에 그리고, 프로세스들이 운영체제에 대한 접근을 차단할 수
  있어야 한다.
  
* 메모리 공간의 종류
- 정적으로 할당되는 메모리
  > 프로그램 실행 전 모든 위치 및 크기 결정, 실행 중 절대 바뀌지 않음.
  > 전역 변수 및 static 변수가 해당, "컴파일러에 의해" 데이터 영역에 생성
- 동적으로 할당되는 메모리
  > 프로그램 실행 중 위치 및 크기가 바뀜
  > 지역 변수 및 malloc 등의 동적 메모리 할당 함수를 통해 만들어 관리됨
  > 지역 변수는 "컴파일러에 의해" stack 영역에서 생성 및 삭제가 관리됨
  > 그 외에는 "프로그래머에 의해" malloc/free, new/delete 등의 동적 메모리 관리 함수를 통해 생성 및 삭제
  > JAVA 및 Python 등에선 생성은 프로그래머에 의해, 삭제는 Garbage Collection(GC)에 의해 자동으로 이루어짐
  
* 메모리 관리 오류
1. 메모리 미할당
2. 부족한 메모리 할당
3. 메모리 관리 오류 : 초기화 되지 않은 메모리 사용
4. 메모리 관리 오류 : 메모리 누수
5. 메모리 관리 오류 : Dangling Pointer (여전히 메모리가 사용중인 메모리 해제)
5. 메모리 관리 오류 : Double Free
