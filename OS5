* 메모리 가상화
- 제한적 직접 실행과 마찬가지 기법을 통해 효율성과 제어를 추구한다.
- 레지스터 / Page Table / MMU / TLB 등의 하드웨어 지원을 이용
- 프로세스의 메모리 접근 권한은 운영체제에 의해 제어되어 다른 프로세스의 메모리에 대한 접근이 차단된다.

* 주소 변환
- 하드웨어를 통해 가상 주소 > 물리 주소로 변환
- CPU를 경계로 이루어짐
  = CPU 상에서 프로세스는 가상 주소로 동작함
  = 보다 구체적으로는 CPU의 명령어 가져오기(Fetch)와 메모리 참조(MEM)이 가상 주소를 기반으로 동작함
- CPU 외부의 메모리 참조는 모두 물리 주소 기반으로 이루어진다.

* 동적(하드웨어-기반) 재배치
- CPU는 base, bound 레지스터를 제공
- 각 프로그램은 주소 0에서 실행되는 것처럼 컴파일됨
- 프로그램 시작 시, 운영체제가 프로그램이 실행될 물리 메모리 위치를 결정하고, 이를 베이스 레지스터에 설정
- 프로그램 실행 시, 모든 메모리 참조는 아래 식을 통해서 변환됨
  > physical address = virtual address + base
  
* 바운드 레지스터
- 가상 주소 공간의 크기를 결정한다.
- 만약, 프로세스가 이 범위를 벗어나서 메모리 접근을 시도할 경우, CPU는 즉시 예외를 발생시켜 운영체제에 알린다.

* 운영체제 이수
- 프로세스 실행 시 : OS는 새 주소 공간을 위한 물리 메모리를 Free list에서 찾는다.
- 프로세스 종료 시 : OS는 프로세스가 사용하던 물리 메모리를 회수하여 Free list에 추가한다.
- Context switch 시 : OS는 베이스/바운드 레지스터 쌍을 백업/복원해야 한다. 이들 정보는 PCB에 저장될 것이다.

! 동적 재배치는 효율적이며 프로세스에 투명하고, 프로세스 보호 기능 또한 제공한다는 장점이 있다. 하지만
  베이스 ~ 바운드 사이의 물리 메모리는 실제 사용 여부에 관계 없이 무조건 특정 프로세스에 점유되므로 
  내부 단편화(internal fragmentation) 문제가 발생한다.
  > 이를 해결하기 위해선, 베이스/바운드 레지스터를 좀 더 일반화 해야 함
  
* 세그멘테이션
- 베이스/바운드의 일반화된 형태
- 프로세스마다가 아닌 주소 공간의 논리적인 세그먼트마다 베이스/바운드 쌍 존재
- 코드, 스택, 힙 등의 세그먼트들이 존재
- 세그먼트 영역을 벗어나 메모리 접근을 할 경우, 세그먼트 폴트가 발생한다.
> physical address = offset + base
- 최상위 몇 비트를 사용하여 어떤 세그먼트의 베이스/바운드를 가리키는지 구분하고 파악한다.
- 물리 주소를 계산할 때 stack은 역방향으로 자란다는 사실을 고려해야함.

* 공유 자원
- 프로세스 간에 메모리를 공유할 경우 메모리 효율성 증가
- 그러나, 공유 시 보안 문제가 발생할 수 있음
- 따라서, 세그먼트 레지스터에 메모리 접근 권한을 설정 할 수 있도록 하드웨어 기능이 확장되어야 함

* 외부 단편화(External Fragmentation)
- 서로 다른 크기의 메모리가 비연속적으로 할당됨에 따라, 할당된 메모리 사이에 작은 크기의 빈 공간들이 생기는 문제
- 이로 인해 여유 메모리가 충분함에도 불구하고 새로운 메모리 할당이 불가능해진다.
> 운영체제가 물리 메로리를 재배치하고 세그먼트 레지스터의 값을 조정함으로써 외부 단편화 문제 해결 가능

* 빈 공간 관리
- 모든 메모리가 고정 크기의 단위로 나뉘어져 있을 경우 빈 공간 관리는 쉽다.
- 하지만 malloc/new 와 같은 가변 크기의 빈 공간들을 할당하면 빈 공간 관리가 어려워지고 이로 인해
  외부 단편화 문제가 발생할 수 있다.
  
* 저수준 기법들
- 분할(splitting) : 빈 공간 리스트에서 요청된 할당 크기보다 큰 메모리 덩어리를 찾은 후, 이를 두개로 분할
- 병합(coalescing) : 기 할당된 메모리를 해제할 경우, 해당 chunk는 빈 공간 리스트에 들어가는데 이들끼리
  병합하여 더 큰 chunk를 만든다.
- 할당된 공간의 크기 파악 : 대부분의 메모리 할당기는 할당한 메모리 앞에 추가 정보를 저장하기 위한 헤더
  블록을 가진다. 헤더에는 할당된 메모리의 크기 정보와 다음 블록의 위치를 저장하는 포인터, 안정성 검사를 
  위한 매직 넘버 등의 기타정보를 가진다.
  
* 빈 공간 관리 : 기본 전략
- 최적 적합 : 요청한 크기보다 큰 빈 공간들 중, 가장 작은 빈 공간. 즉, 요청한 크기와 가장 맞는 빈 공간
  을 찾는다. 이는 전체 리스트를 검생해야 하므로 오버헤드가 증가한다.
- 최악 적합 : 가장 큰 빈 공간을 찾는다. 전체 리스트를 검색해야 하므로 오버헤드가 증가하고, 외부 단편화
  문제 또한 발생시킨다.
- 최적 적합 : 메모리 할당을 할 수 있는 첫 번째 빈 공간을 찾는다. 이는 빠르지만 리스트 초반부에 메모리 
  단편화가 집중될 수 있다.
- 다음 적합 : 항상 리스트의 처음부터 시작하는 대신, 이전에 탐색이 끝난 위치부터 탐색을 시작한다. 전체
  메모리를 탐색하지 않으므로 빠르고, 리스트 초반부에 메모리 단편화가 집중되는 것을 방지한다.
  
* 개별 리스트
- 서로 다른 크기의 빈 메모리 chunk를 관리하는 다수의 빈 공간 리스트를 관리한다.
- 정해진 크기의 메모리 chunk를 할당 해제하므로 분활 및 병합이 필요 없어 외부 단편화를 줄일 수 있고, 
  메모리 할당을 위한 탐색 시간을 줄일 수 있다.
  
* 버디 할당
- 리눅스 물리 메모리 관리를 위해 사용된다.
- 이진 버디 할당 : 메모리 할당 요청이 들어오면, 해당 요청을 만족시킬 수 있는 한, 계속해서 메모리를 
  반으로 쪼갠 후 할당한다.
  > 내부 단편화 문제 발생 가능, 할당된 메모리 해제 시 인접 메모리 chunk 또한 해제된 상태면 할당과 다르게
  역방향으로 메모리가 병합된다.
  
