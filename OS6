* 세그멘테이션
- 가상 메모리는 세그먼트라 불리는 가변 크기의 조각들로 물리 메모리에 매핑 됨.
- 외부 단편화 문제가 발생할 수 있음

* 페이징
- 가상 메모리는 페이지라 불리는 고정 크기의 조각들로 물리 메모리에 매핑 됨.
- 외부 단편화 문제를 해결할 수 있음
- 페이지에 매핑되는 물리 메모리 조각은 페이지 프레임이라고 불림.
- 개당 16B 크기

! 현대 컴퓨터에서는 페이징이 주로 사용됨.

* 페이징 주소 변환
- 주소 공간의 각 페이지가 어떤 페이지 프레임에 매핑되는지 기록하기 위해 페이지 테이블(Page Table)이 사용됨.
- 운영체제는 각각 주소 공간을 가지는 프로세스 마다 별도의 페이지 테이블을 가지도록 관리
- 운영체제가 관리한 페이지 테이블은 CPU 내에 있는 MMU에 참조되어 메모리 변환을 하드웨어적으로 수행함.
- 가상 주소는 두 요소로 구성됨
  > VPN : 페이지 테이블에서 페이지 선택
  > Offset : 페이지 내에서 원하는 바이트 위치를 나타냄
  > VPN(2bit) + Offset(4bit)
- 가상 메모리 공간인 페이지와 물리 메모리 공간인 페이지 프레임의 크기는 동일하다
  > offset은 변환할 피요 없음
  > VPN은 페이지 테이블을 통해서 물리 프레임 번호(PFN)로 변환됨. / PFN(3bit) + Offset(4bit)
  
* 페이지 테이블 크기
- 32bit 시스템 기준
  > 각 프로세스의 주소 공간 - 32bit
  > 각 페이지의 크기 4kb
  > vpn은 20bit, offset은 12bit
  > 각 페이지 테이블 엔트리(VPN에 대응되는 PFN정보)의 크기는 4B
  > 프로세스 별 페이지 테이블의 크기 = 4MB = 2^20entries * 4Bytes per page table
- 프로세스의 수에 비례하여 페이지 테이블에 필요한 메모리가 증가
- 페이지 테이블은 메인 메모리(커널)에 저장되며, 메모리가 부족할 경우 디스크로 스왑되어 저장될 수도 있다.

* 페이지 테이블을 통해 페이지를 찾는 과정
- PT는 다수의 PTE로 구성
- CPU에서 가상 주소로 메모리 접근이 발생하면 MMU는 PT를 참조하여 VPN에 대응되는 PTE를 찾는다
- PTE에는 PFN뿐 아니라 MMU 메모리 변환을 컨트롤하는 다양한 flag 필드 존재
- MMU는 PTE를 참조해 가상 주소를 물리 주소로 변환하거나, 변환하지 않고 CPU에 변환 실패를 알리는 인터럽트를
  보내기도 함.
  
* 페이지 테이블의 공통적인 flag들
- Valid bit : 해당 PTE가 유효한지
- Protection Bit : 해당 페이지가 읽을 수 있는지(1), 쓸 수 있는지(2), 실행할 수 있는지 표시(3)
- Present Bit : 이 페이지가 메모리에 존재하는지 혹은 디스크에 존재하는지 표시
- Dirty Bit : 해당 페이지가 수정이 된 적 있는지 표시
- Reference Bit(Accessed Bit) : 해당 페이지에 접근(read or write)이 있었는지 표시

* 페이징의 문제점
- 너무 느림
  > 가상 주소를 물리 주소로 변환하기 위해 MMU는 매번 가상 주소에서 VPN을 구하고 PT에서 대응되는 PTE를
    찾아야 한다. PTE를 찾은 후에는 각종 flage들을 통해 해당 주소 변환을 수행할지 결정하고 주소 변환을
    결정한 후에는 PTE 내에서 PFN을 찾아야한다. PFN을 찾으면 offset과 더해 가상 주소에 대응되는 최종
    물리 주소를 구하게 된다/
 - 이를 해결하기 위해 TLB(translation-lookaside buffer)라고 부르는 Cache를 사용한다.
 
 * TLB
 - MMU에 있는 작은 주소 변환 캐시
 - MMU에는 먼저 TLB를 탐색해보고, Miss가 발생할 경우 Page Table을 탐색하게 된다.
 - 주소 변환을 수행하다 TLB miss가 발생하면, 페이지 테이블을 탐색하여 PTE를 찾은 후 PFN 등의 정보를 
   TLB에 추가해야한다.
 - TLB miss는 하드웨어에 의해 직접 처리되거나, 소프트웨어(운영체제)가 직접 TLB에 값을 쓸 수 있는 전용
   명령어를 통해서 처리 될 수 있다.
   
 * TLB 엔트리
 - TLB는 32, 64, 또는 128개의 엔트리로 구성된다.
 - TLB는 탐색 시간 최소화를 위해 Fully associative 방식으로 설계된다.
 - 즉, 모든 엔트리에 대해 동시에 병렬적으로 탐색한다.
 - VPN + PFN + other bits(valid, protection, dirty, address-space identifier)
 
 * TLB 문제점
 - TLB는 하나의 캐시로, 각 프로세스가 공유하여 사용한다. 따라서 Context switching이 발생하면 같은 VPN
   에 대하여 다른 정보를 담고 있을 수 있다.
 - 이를 해결하기 위해 최신 CPU들에는 TLB내 주소 공간을 식별할 수 있도록 ASID(Address Space Identifier) 
   or PCID(Processor Context Identifier)항목이 추가되엇다.
 - 커널과 같이 모든 프로세스에서 공유하는 주소 공간은 굳이 ASID로 관리될 필요가 없기 때문에 PTE의 G flag
   를 활성화하여 ASID의 영향을 받지 않도록 한다.
   
 * TLB 교체 정책
 - LRU (Least Recently Used) : 시간 지역성을 최대한으로 활용
   > 한계점 : 메모리 접근 패턴에 따라 worst case, 특히 n개의 TLB 엔트리에 대해 n+1 페이지에 대해 메모리
   접근을 반복할 경우 문제 발생 -> 이를 해결하기 위해 랜덤으로 TLB 엔트리를 교체하는 정책을 사용할 수 있음
 
 * 페이지 테이블 오버헤드
 - 선형 페이지 테이블
  > 페이지 테이블이 PTE 배열 형태를 가진다고 가정
  > 32bit 시스템 + 4kb 페이지 가정
  -> 프로세스 별 페이지 테이블의 크기 : 4MB = 2^20 * 4 Bytes per page table entry
  > 100개의 프로세스 존재 -> 400MB 소비
 - 더 큰 페이지(페이지당 16KB)를 가정
  > VPN : 18bit, offset : 14bit(16KB)
  -> 프로세스 별 페이지 테이블의 크기 : 1MB = 2^18 * 4Bytes per page table entry
  ! 그러나 이 경우 각 페이지에서 공간이 낭비되는 내부 단편화 문제가 발생
  
  # 하나의 페이지 테이블을 이용하기 때문에 미 사용 주소 공간에 대한 불필요한 PTE 유지가 문제의 원인!
  
* 하이브리드 접근 방법 : 페이징 + 세그먼트
- 실 사용 영역들(코드, 힙, 스택 등)에 대해 각각 페이지 테이블을 만듦 -> 미사용 영역에 대한 오버헤드 감소
- segment big(2bit) + vpn(18bit) + offset(12bit)
- 세그먼트의 베이스 레지스터와 VPN을 통해 PTE의 물리 주소를 얻는다.

* 하이브리드 방식의 문제점
- 힙과 같이 메모리가 드문 드문 사용되는 경우 여전히 페이지 테이블 공간이 낭비됨
- 세그먼트의 크기에 비례하여 페이지 테이블의 크기가 결정됨

* 멀티 레벨 페이지 테이블(Multi-level Page Table)
- 선형 페이지 테이블을 트리 형태로 표현
- 실제 물리 메모리로 매핑되는 주소 공간에 대해서만 페이지 테이블을 관리함으로써 불필요한 페이지 테이블
  낭비를 최소화함.
  
* 멀티 레벨 페이지 테이블의 구성
- 전체 페이지 테이블(PTE 배열)을 페이지 크기의 단위(4KB)로 나눈다
- 페이지 테이블의 페이지 중 유효한 PTE가 하나도 없으면 해당 페이지를 할당하지 않는다.
- 유효한 PTE가 하나라도 있으면 할당하며, 이렇게 할당된 페이지 테이블의 페이지들은 페이지 디렉토리라는
  자료구조에 의해서 참조된다.
- PTBR(Page Table Base Register)
  > MMU가 참조해야 할 페이지 테이블의 시작 물리 주소를 가리킴
  > 멀티 레벨 페이징에선 페이지 디렉토리의 시작 물리 주소를 가리키기 됨
- 페이지 디렉토리
  > 페이지 테이블과 마찬가지로 엔트리(PDE, Page Directory Entry)로 구성됨
  > 각 PDE는 대응되는 하위 페이지 테이블에 대한 정보를 담고 있음(valid, address)
  
* 멀티 레벨 페이지 테이블 장단점
- 장점 :
  > 실제 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간을 사용
  > 고정된 크기(페이지,4kb)로 페이지 테이블 및 페이지 디렉토리의 할당 및 해제가 이루어진다.
  > 큰 페이지를 사용할 때 대비 내부 단편화 감소
  > 세그먼트를 사용할 때 대비 외부 단편화 감소
- 단점 :
  > 주소 변환에 페이지 디렉토리를 참조하는 과정이 추가됨
  > TLB miss 발생 시 오버헤드 증가
  > 구현이 좀 더 복잡해짐
  
+ 멀티 레벨 페이지 테이블을 통해 보다 넓은 가상 주소 공간을 제공하기 위해서 2단계 이상으로 사용할 수 있다.
